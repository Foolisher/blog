---
title: 面试题5
date: 2018-05-22 16:38:56
tags:
  - 面试
---



## 一、Java相关

#### 1. 乐观悲观锁的设计，如何保证原子性，解决的问题；（80分）

>  乐观锁使用一种后置check机制保障更新时更新的是自己预期的值，它的操作无需并发加锁，因此并发度和吞吐量很高；而悲观锁就是在读写资源是将资源锁住，会导致其他并发线程无法进入，导致大量线程等待、阻塞，但是它在保证事务型操作上又会比乐观锁好使，彻底锁住一个资源，保证事务的强一致性



#### 2. char和double的字节，以及在内存的分布是怎样；（40分）

> char，32位机器16bit(8byte)；64位机器16bit(8byte)；double，32位机器64bit(8byte)，64位机器64bit(8byte)；



#### 3. 对象内存布局，然后讲下对象的死亡过程？（20分）

> 对象内存布局分为三大块：对象头；实例数据；内存填充；
>
> 实例数据包含
>
> 内存对其：HotSpot规范要求，对象的大小必须是8的整数倍，因此对象内存布局时也会尽量将类型相近的放在一起
>
> 栈帧：栈帧是对函数操作的上下文就，如方法入口，方法返回，方法临时变量，入参，出参，上一个栈帧的栈底指针



#### 4. 对象头，详细讲下；（40分）

> 对象头又包含：运行时数据，和类型指针两块。运行时数据是对象在运行时状态变化的信息，如HashCode、GC分代年龄、锁状态、偏向锁线程ID



#### 5. sync原理详细，sync内抛异常会怎样，死锁吗？还是释放掉？怎么排查死锁？死锁会怎样？有没有什么更好的替代方案？（80）

> sync是通过monitorenter和monitorexit的语意保证代码临界区的访问，sync内抛出异常的话会导致线程释放锁的；
>
> 死锁可以通过dump线程排查，如果发现线程有wait lock字样，那么无疑是死锁了；可以用乐观锁机制更快捷，和使用java concurrent包；
>
> 死锁解决方案：尽量不要子资源里面在申请资源，容易导致相互持有锁；尽量减少资源获取次数，资源打散后容易造成死锁；可以使用锁超时避免死锁但不是最好的解决办法



#### 6. 详细讲一下集合，HashSet源码，HashMap源码，如果要线程安全需要怎么做？（90）

> HashSet是通过包装HashMap来实现的，只是它的Value是一个固定的值，要保障线程安全，对于HashMap可以使用并发的HashMap，而HashSet也有对应实现的并发HashSet，或者自己通过锁来保障线程安全



#### 7. 多线程是解决什么问题的？线程池解决什么问题？

> 提高吞吐量、降低RT、尽量利用多核CPU；合理分配线程池，任务处理逻辑，丢弃逻辑，资源重复利用



#### 8. 线程池，如何设计的，里面的参数有多少种，里面的工作队列和线程队列是怎样的结构，如果给

#### 你，怎样设计线程池？（70）

> - corePoolSize
> - maxPoolSize
> - TaskQueue
>   - ArrayBlockingQueue
>   - LinkedBlockingQueue
>   - SynchronousQueue：
> - reject-policy
>   - AbortPolicy：throw RejectExecutionException
>   - DiscardPolicy：直接丢弃
>   - DiscardOldestPolicy：淘汰策略
>   - CallRunsPolicy：交给主线程调度侧率
>
> 



#### 9. AQS原理，ReentranLock源码，设计原理，整体过程。（20分）

> 抽象同步队列，简述下重入锁的原理
>
> 1. acquire(1)
> 2. tryAquire(1): cas(0,1) && setExclusiveThread(Thread.currentThread())
>    1. if(tryAcquire(1)==false): 
> 3. if(state>0 && this.exclusiveThread==Thread.currentThread()) state++ and return;



#### 10. 继续聊多线程源码，sync原理，然后一个场景设计题；

> synchronized
>
> volatile



#### 11. float f = 1.4f;double d = 1.4d; 与 float f = 1.5f;double d = 1.5d; 是否为true，内存是怎样的；

> 



#### 12. split的源码，split("a|b|c");得出多少个数组；



#### 13. 把所有认识熟用的JUC( java.util.concurrent(简称JUC)包)下的类写出来，讲下使用，然后讲下原生的线程操作;（30分）

> AtomicLong
>
> AtomicReference



#### 14. 开闭原则，解析工厂方法模式，建造者模式，区别。手撸出来。（40分）

> 对修改关闭，对新增开放：结构模式里面的装饰器模式、代理模式、外观模式等
>
> 抽象模式：抽象工厂，具体工厂



#### 15. 讲下JVM的大页模式，JVM内存模型;（40分）

> 堆区：；方法区：；PC：；jvm栈：；本地方法栈：；JNI：；NativeLib：；



#### 16. 什么是敏捷开发，防御性编程，并行编程。Team Leader的思考;（20分）

> 敏捷：？
>
> 防御式：内存溢出；业务错误；网络异常；资源限制；
>
> Concur：



#### 17. 逃逸分析是什么，作用是什么，用途是什么;

> 在一个栈内分配的对象被其他静态，或其他栈帧引用到，而没有被销毁。



#### 18. 怎么认为一个类是线程安全？线程安全的定义是什么？Java有多少个关键字进行同步？为什么这样设计？（聊了一大堆，一堆为什么）；（70分）

> 不会出现并发读写情况就是现场安全的；或者说不可变的就是现场安全的；也或者说有保护机制的读写是线程安全的
>
> 同步的关键字一般有synchronized、lock、wait、volatile等机制
>
> 为什么用synchronized？
>
> 为什么用wait()？
>
> 为什么用lock？



#### 19. 两个线程设计题。记得一个是：t1,t2,t3，让t1，t2执行完才执行t3，原生实现。（30分）

> 1. t3 join t1,t2
> 2. t3里面submit后get等待t1,t2线程
>
> 对线程执行机制不精通



#### 20. 写个后缀表达式，为什么要设计后缀表达式，有什么好处？然后写下中缀。（20分）

> 知其然不知其所以然，数据结构算法能力欠缺



#### 21. 我看你做过性能优化，比如你怎么分析项目里面的OOM的，内存泄露呢？详细说思路;

> dumpHeap，通过mat等工具分析占用内存较多的对象
>
> 内存泄露同理也是找到占用较多的地方，但是同时在编写程序时也要有防御式措施，避免大对象，多对象被不断加入到无法回收的引用中



#### 22. 说下多线程，我们什么时候需要分析线程数，怎么分析，分析什么因素;（20分）

> 1. 线程不是越多越好
> 2. 单核多线程也可以给程序带来并发效果
> 3. ​



#### 23. FullGC 调优解决经验（20分）

>



#### 24. 抽象方法和类方法的区别，static的抽象方法可以吗？

#### 25. 说下Java的克隆体系;

涉及OOM、JVM优化、源码问题、数据库优化、多线程等问题;

CPU高？什么情况CPU高？解决什么问题？

你有遇到过临界区问题吗？有遇到过吗？你在项目遇到这个问题是怎样解决的？

volatile关键字作用;

Java的多态怎么实现;

解释一下自旋;

解释一下信号量;

什么情况下会触发类加载；

Java内存抖动严重，优化的思路；

#### 说说java 中的锁 -- 偏向锁、轻量级锁、自旋锁、重量级锁



## 二、数据库相关

#### 1. SQL优化思路，联合索引与底层树结构的映像关系，索引结构（B+、B-），为什么用这样的结构；

#### 讲下MySQL的集群？集群遇到过什么问题？sql的优化？

#### 你目前为止遇到的最大数据量是多少？知道100万时候怎么设计吗？1000万呢？过几十亿呢？

MySQL有多少个参数可调，除了最大连接数。全部列出来，一个个分析。

聊下优化过的索引，怎么优化;

红黑树和平衡树的区别，为什么数据库不用红黑树;

mysql有哪些锁，意向锁有什么用;

数据库高并发下的优化思路;

数据库什么情况下索引会失效;

#### 主键和唯一索引的区别

> 主键：不为空，只能有一个，可以作为外键被索引，



## 三、数据结构和操作系统相关

- 数据结构学过吧，聊一下？学过什么结构？讲下树和队列？B树呢？
- 操作系统学过吧，聊一下？讲一下系统内存是怎样的？分段分页虚拟内存？
- 页面置换算法呢？多少种？有最优的置换算法吗？
- 你学过什么课程？然后聊下操作系统，内核、用户之类。
- 反转链表手撸;
- 快排，给一串数组，把具体每次patition写下，最终结果也写45, 32, 41, 35, 38, 20, 50;
- 一个整数status, 判断第K个比特位是否为比特1;
- 把递归实现的快排改成非递归，你知道非递归有什么好处吗;
- 举例使用分治思想的算法;



## 四、网络相关

#### 1. 讲下请求头细节？（20分）

> 不同的协议栈，有不同的请求头，如ip层请求头主要是ip地址相关；数据链路层主要是arp地址相关；应用层就是端口相关



#### 2. Http和Https？Http1.0,1.1,2.0，讲下长连接和短连接？Https是怎样的？如果我篡改了公钥呢？怎么防止？（0）



#### 3. Get和Post，讲下区别，要我模拟出抓包来。（50）

> GET参数在URL中，POST携带在数据包中提交；GET现在url长度，post比较大，因此适用于提交大数据；



#### 4. 详细讲下Cookie和Session，Token，OAuth2.0协议;

> Cookie：浏览器保存，Session：服务端保存
>
> Token：登陆令牌，用来实现OSS单点登陆，然后发放令牌
>
> 单点登陆：授权中心，用户，服务器；用户登陆服务器，服务器会判断用户登录状态，若未登录会引导到鉴权中心去登陆，登陆后OSS会同步用户Token，然后再次请求服务器并带上Token去请求服务器，此时服务器知道用户已经登陆过了



#### 5. 拥塞算法知道吗？哪些，分别怎样？（0）



#### 6. 学过计算机网络是吧？socket熟悉吗？对它的读写缓冲区有理解吗？怎么的？那滑动窗口是怎样的？为什么这样设计？（0）

> 滑动窗口自适应调整，如果拥塞大了，滑动窗口可以调小，然后拥塞小了再适应调大窗口



#### 7. 再聊下Http的Http basic authentication;

#### 8. Https的过程;



## 五、框架相关

#### 1. 聊下Spring源码，知道多少，都聊一下；（30分）

> IOC，AOP实现原理；
>
> BeanDefinition对POJO建模初始化，辅助已BeanPostProcessor做一些前置和后置的初始化，甚至支持之定义BeanDefinition实现自己的业务Bean代理；
>
> 抽象工厂模式，为不同的Bean容器创建提供不同机制，如FileSystem，AnnotationBean
>
> JDBCTemplate，对jdbc的操作提供模板方法，使得api更加简洁，也便于事务引入
>
> ORM
>
> 事务



#### 2. 聊下Spring注解，@Autowire，@Resource，以及他们的解析过程；（80分）

> 处理BeanDefinition时会将其定义成一个Reference的Property，然后在初始化Bean时会连锁地将其初始化；
>
> 那么怎么处理循环依赖的呢？答：缓存机制，将已经初始化的Bean放入缓存，那么在处理依赖时，若发现依赖已经初始化即可终止连锁初始化



#### 3. 聊一下架构，接入层架构，服务层架构。聊下技术栈，Spring Boot，Spring Cloud、Docker；（30分）

> 网关：容灾，性能压测，api设计原则
>
> 服务层：分布式，
>
> SpringBoot：
>
> Docker



#### 4. Spring ioc的具体优势，和直接New一个对象有什么区别;（70分）

> 将对象的具体依赖交个Spring，不容服务具体依赖具体实现，使得修改替换实现类更加容易，例如RPC的代理；还有ioc很多是单例模式，避免重复创建实例，使得内存占用更少，避免Bean重复创建



#### 5. Servlet生命周期，是否单例，为什么是单例;

> 创建、初始化、doService、销毁
>
> 非现场安全，可以是单例的，而且Servlet的创建代价也很大，无需prototype



#### 6. Spring Mvc初始化过程；

> 解析@Controller、解析@Mapping，将restURl与Method绑定
>
> 解析Mapping时也会解析header、condition，抽象的各种Condition，如HeaderCondition，ParameterCondition



## 五、分布式相关

#### 1. 多少种RPC框架？

> Dubbo、HSF、ZeroC、ProtocolBuff



#### 2. 一致性哈希是干嘛的？

> 目的是为给client提供一致的读写路由，不管后端服务节点如何变化，用户看来他们别路由到的逻辑服务总是没哟错乱的；例如新节点的加入，新用户或许命中了这个节点后，他将一直命中这个节点，保证数据读写一致性，与自己预期符合。



#### 3. 搭建高并发高可用系统需要怎样设计？考虑哪些东西，有多少说多少。

> 1. 分离核心服务和非核心服务
> 2. 避免资源争抢
> 3. 动静分离，主备分离
> 4. 尽早拦截，尽早失败
> 5. 分布式，多进程，多线程
> 6. 消息中心削峰填谷
> 7. 数据容灾、服务负载均衡，熔断，告警
> 8. 限流，扩容，缩容



#### 4. 你对缓存有什么理解？缓存是解决什么问题？后端缓存有哪些，分别解决什么问题？(50分)

> 50分如何说道90分？



#### 5. 聊一下分布式锁；（60分）

> 多进程获取锁的情况
>
> 可以用缓存、zk等中心化协调中间件做分布式锁。怎么解决锁一直无法释放问题？加锁时加上最大失效时间，但是并不去实际失效，如果其他进程来查这个锁的状态时发现这个锁已经加锁太长时间，它可以强制加锁
>
> 加分项：



#### 6. 你是怎么设计系统缓存的，为什么，什么场景；（70分）

> 分布式缓存，分布式访问场景，容量大，但有网络瓶颈
>
> 本地缓存：GuavaCache，或ConcurrentHashMap，性能好，容量低，可以用作二级缓存
>
> **加分项**：



#### 7. 也来说下，削峰的多种实现，Redis？MQ？

> MQ：ConsummerGroup并发消费，消费者pull模式消费



## 六、设计题

#### 1. 有几台机器存储着几亿淘宝搜索日志，你只有一台2g的电脑，怎么选出搜索热度最高的十个搜索关键词;（90分）

> 分治策略：分到多个文件，用hash算法把搜索词Sharding到多个文件，如果找到很大的文件，那么再次将其hash，当文件hash到足够小时，读取各个文件里面的日志，用countBy聚合统计出各个文件里面top10搜索最高的词，TOPN算法如果是动态的话，可以用堆来实现



#### 2. 如何设计算法压缩一段URL;（90分）

> 把URL转换成内存数据库kv；把URL转换成mysql，对应成一种自增id



#### 3. 有一个页面能同时展示两个广告，现在有五个广告，设计算法使五个广告展示概率为1:2:3:4:5；

> 原理：概率，得到分子，得到分母，随机性打算即可；
>
> 5:10:15:20:25 共这么多span，然后随机从里面取出2个广告投放
>
> 权重随机概率，1:



#### 4. 有25匹马，五个赛道，用最少比赛次数将25匹马排序；

> 每次比赛，插入排序，淘汰掉



## 七、其他相关

#### Tomcat缓存，聊下缓存的整体理解，知道多少种缓存；

#### 解释下Mucene原理，倒排索引，怎样进行中文分词，基于什么进行分词；

#### TopN的大数据量题；

#### 你对接入层要思考什么东西？遇到过哪些问题？搭建系统要考量哪些因素？

> 安全；接口稳定；稳定性；性能；容灾；

#### 然后项目问题，优化问题；

> 1. 你做过哪些优化？

#### 熟悉maven是吧？我们来聊下Maven的源码原理，Maven冲突的时候，怎么选择依赖包，我们怎么查，我们遇到两个不一样的版本，我们应该如何去选择，为什么？

#### 项目如何分组，性能优化小组应该做哪些;

#### 我们来说下接入层的搭建，认知分析;

#### 问下项目的系统构建，思考，为什么这样构建？

> 业务预判，领域模型思考，按业务垂直切分，按功能做水平层次划分，抽象出上层服务，基础服务，关键需求服务；
>
> 找出业务的基础能力，



#### 如何判断一段代码的好坏;

> 首先简单的方法实现服务是第一位，然后是看逻辑是否清晰，是否表达清楚业务，可读性上比较强；再者是抽象程度、有没防御逻辑，有没安全校验逻辑，有没异常处理机制以及异常判断
>
> 然后是性能问题

